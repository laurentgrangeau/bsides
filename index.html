<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>An Interactive History of Memory Protection</title>
    <script src="https://cdn-tailwindcss.vercel.app/"></script>
    <!-- Chosen Palette: Warm Neutrals -->
    <!-- Application Structure Plan: The application uses a sequential, section-based flow. The user starts with a full timeline, then can navigate to focused hardware and software sections. This structure was chosen to guide the user through the complex history in a logical, step-by-step manner, mirroring a structured presentation, rather than offering a purely exploratory filter-based interface. The user flow is linear (Next/Previous), supported by keyboard and clicker controls, making it ideal for a presentation setting. The pop-out speaker notes window supports a dual-screen presenter setup. -->
    <!-- Visualization & Content Choices: The core visualization is an interactive, horizontal timeline built with HTML and Tailwind CSS, as it's the most intuitive way to present historical data. Report Info: Each technology slide. Goal: Show chronological relationship and provide details on demand. Viz/Presentation Method: Clickable nodes on the timeline. Interaction: Clicking a node updates a detailed content panel. The panel separates technical details from the narrative/story for clarity. Justification: This transforms passive content into an active exploration tool, enhancing user understanding and engagement. No traditional charts are needed as the timeline itself is the primary data visualization. All interactions are powered by vanilla JavaScript. CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        html, body {
            height: 100%;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #FDFBF8; /* Warm off-white */
            color: #4A4A4A; /* Dark gray */
        }
        .timeline-container {
            position: relative;
            width: 100%;
            overflow-x: auto;
            padding: 20px 0;
            scrollbar-width: none; /* Hide scrollbar for Firefox */
        }
        /* Webkit scrollbar styling for Chrome, Safari, etc. */
        .timeline-container::-webkit-scrollbar {
            display: none; /* Hide scrollbar for Webkit browsers */
        }
        .timeline {
            display: flex;
            position: relative;
            padding: 50px 0; /* Increased vertical padding for content */
        }
        .timeline::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            width: 5400px; /* Extended width for horizontal scrolling */
            height: 4px;
            background-color: #D1D5DB; /* Cool Gray 300 */
            transform: translateY(-50%);
        }
        .timeline-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; /* This centers the dot on the line */
            position: relative;
            flex-shrink: 0;
            width: 150px;
        }
        .timeline-dot {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 4px solid #FDFBF8;
            background-color: #D1D5DB;
            position: relative;
            z-index: 10;
            cursor: pointer;
            transition: transform 0.2s ease, background-color 0.2s ease;
        }
        .timeline-item:hover .timeline-dot {
            transform: scale(1.2);
        }
        .timeline-item.active .timeline-dot {
            transform: scale(1.3);
        }
        .timeline-item[data-type="hardware"].active .timeline-dot { background-color: #3B82F6; /* Blue 500 */ }
        .timeline-item[data-type="software"].active .timeline-dot { background-color: #10B981; /* Emerald 500 */ }
        .timeline-item[data-type="intro"].active .timeline-dot,
        .timeline-item[data-type="none"].active .timeline-dot {
            background-color: #6B7280; /* Gray 500 */
        }
        
        .timeline-content {
            text-align: center;
            cursor: pointer;
            padding: 10px;
            position: absolute; /* Position content absolutely to avoid overlap */
            width: 100%;
            left: 0;
        }
        /* Position odd items' content BELOW the line */
        .timeline-item:nth-child(odd) .timeline-content {
            top: 50%;
            margin-top: 15px; /* Push it down from the center */
        }
        /* Position even items' content ABOVE the line */
        .timeline-item:nth-child(even) .timeline-content {
            bottom: 50%;
            margin-bottom: 15px; /* Push it up from the center */
        }
        .card {
            background-color: #FFFFFF;
            border: 1px solid #E5E7EB; /* Cool Gray 200 */
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            transition: all 0.3s ease;
        }
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .filter-btn.active {
            background-color: #fff;
            color: #3B82F6;
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
        }
    </style>
     <link rel="preconnect" href="https://fonts.googleapis.com">
     <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
     <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
</head>
<body class="antialiased">

    <div class="w-full min-h-screen p-4 md:p-6 lg:p-8 flex flex-col">
        <header class="text-center mb-6 flex-shrink-0">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-800">A Journey Through Memory Protection</h1>
            <p class="mt-2 text-md text-gray-600">An interactive timeline of hardware and software defenses.</p>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-4 gap-6 flex-grow">
            <aside class="lg:col-span-1">
                <div class="card p-4 sticky top-8">
                    <nav class="flex justify-center items-center space-x-2 mb-4 p-2 bg-gray-100 rounded-xl max-w-sm mx-auto">
                        <button id="filter-all" class="filter-btn active flex-1 py-2 px-4 rounded-lg text-sm font-semibold transition-colors duration-200">All</button>
                        <button id="filter-hardware" class="filter-btn flex-1 py-2 px-4 rounded-lg text-sm font-semibold transition-colors duration-200">Hardware</button>
                        <button id="filter-software" class="filter-btn flex-1 py-2 px-4 rounded-lg text-sm font-semibold transition-colors duration-200">Software</button>
                    </nav>
                    <h2 class="text-lg font-semibold mb-2 text-center text-gray-700">Timeline of Innovations</h2>
                     <div class="timeline-container">
                        <div id="timeline" class="timeline">
                            <!-- Timeline items will be injected here by JavaScript -->
                        </div>
                    </div>
                </div>
            </aside>

            <section id="details-panel" class="lg:col-span-3 fade-in">
                 <!-- Details will be injected here by JavaScript -->
            </section>
        </main>
    </div>

    <script>
        const protectionData = [
            { id: -1, title: "Laurent Grangeau", date: "Introduction", type: "intro", bio: "Your brief bio goes here. Mention your expertise, your interest in the topic, and what the audience will learn from this presentation. Keep it engaging and concise.", photoUrl: "https://placehold.co/128x128/EFE8D9/4A4A4A?text=Your\\nPhoto", pioneer: "Introduction Slide", story: "This is the introduction to our journey through the history of memory protection, setting the stage for the innovations to come.", narrative: "Welcome everyone. Today we're going on a journey to explore the fascinating arms race between attackers and defenders that has shaped the very silicon and software we use every day." },
            { id: 0, title: "The Wild West: No Protection", date: "1940s-1950s", type: "none", what: "Early systems had no memory protection. Any program could read or write to any part of memory, including the operating system's memory.", how: "The CPU directly accessed physical memory addresses.", protects: "Nothing. A single faulty or malicious program could crash the entire system or corrupt other programs.", pioneer: "Early computing architectures.", story: "The story here is the chaos of early multitasking and batch-processing systems. A simple bug in one user's job, like an array index going out of bounds, could overwrite the data of the *next* person's job in the queue or even corrupt the core operating system monitor, causing a system-wide crash and halting all processing for everyone.", narrative: "Frame this as the primordial state of computing. These early machines were designed to run one program at a time, from start to finish. The idea that a program might be hostile or even just buggy wasn't a primary concern. The lack of protection was a reflection of this single-task mindset, which quickly became untenable as computers became more powerful and began to serve multiple users.", imageUrl: "https://placehold.co/400x300/EFE8D9/4A4A4A?text=Chaos" },
            { id: 1, title: "Base and Bounds Registers", date: "~1959", type: "hardware", what: "A simple hardware mechanism using two registers: a `base` register and a `bounds` (or `limit`) register.", how: "The `base` register stores the starting physical address of a program's memory. The `bounds` register stores the size of that memory block. The CPU checks every memory access to ensure it's between `base` and `base + bounds`.", protects: "A program accessing or overwriting the memory of another program or the operating system.", pioneer: "CDC 6600 supercomputer.", story: "The chaos of early multitasking systems is the story here. Without this, a bug in one user's batch job (e.g., an array index out of bounds) could overwrite the data of the next person's job or even corrupt the core operating system monitor, causing a system-wide crash.", narrative: "This is the first, most intuitive step towards sanity. It's like putting up a simple fence in a field. We tell a program, 'You can play anywhere you want inside this fenced area, but the moment you try to step outside, you're stopped.' It was a crude but effective first attempt to draw a hard line in the silicon between different programs.", imageUrl: "images/base-and-bounds.png" },
            { id: 2, title: "Paging & Virtual Memory", date: "~1962", type: "hardware", what: "A memory management technique where the address space is divided into fixed-size blocks called 'pages'.", how: "The Memory Management Unit (MMU) in the CPU translates virtual addresses used by a program into physical addresses in RAM. Each process gets its own isolated virtual address space.", protects: "One process directly accessing the memory of another. It's the foundation of modern OS memory isolation.", pioneer: "Atlas Computer.", story: "This is what enables modern, stable operating systems. Before this was common, in systems like early MS-DOS with TSR (Terminate and Stay Resident) programs, multiple programs coexisted in the same physical address space. A bug in one could easily corrupt another, leading to the infamous 'Blue Screen of Death' or unexplained system crashes. Paging gives each program its own private sandbox.", narrative: "This is one of the most important concepts in modern computing. We create an illusion for every program: the illusion that it has the entire computer's memory all to itself. It's like giving every family their own private mansion on a map, even though they all actually live in different apartments in the same building (physical RAM). The MMU is the concierge who directs them to their real apartment, ensuring they never accidentally walk into their neighbor's home.", imageUrl: "images/paging-virtual-memory.png" },
            { id: 3, title: "Protection Rings", date: "~1967", type: "hardware", what: "A hierarchical system of privilege levels implemented in hardware, most commonly **Ring 0 (Kernel Mode)** and **Ring 3 (User Mode)**.", how: "Code in a lower-privilege ring cannot access memory or execute instructions belonging to a higher-privilege ring. System calls are used to request services from the kernel.", protects: "User applications tampering with the core operating system kernel.", pioneer: "GE 645 mainframe for the Multics OS.", story: "The story is about **privilege escalation**. Early exploits against systems like UNIX involved tricking the kernel into running user-supplied code at the kernel's privilege level. Protection Rings are the fundamental hardware barrier that prevents user code from directly modifying critical kernel structures like the Interrupt Descriptor Table (IDT).", narrative: "Think of this as creating a caste system for code. The operating system kernel is the king (Ring 0), and applications are the peasants (Ring 3). Peasants cannot touch the king's property. If a peasant needs something important, like access to a file, they must formally ask the king's officials for it through a 'system call.' This enforces order and protects the ruler from the ruled.", imageUrl: "images/protection-ring.png" },
            { id: 4, title: "Segmentation", date: "~1970s-1982", type: "hardware", what: "A memory management scheme where memory is divided into variable-sized segments, corresponding to logical parts of a program (e.g., `code` segment, `data` segment, `stack` segment).", how: "A memory address is composed of a segment identifier and an offset. The hardware uses a descriptor table to check the segment's base, size, and permissions on every access.", protects: "A program accessing memory outside its intended logical segment, e.g., a data overflow overwriting code.", pioneer: "Intel 80286 CPU.", story: "The story is about preventing logical errors from becoming security flaws. For example, a buffer overflow on the stack (a data segment) could, without segmentation, easily bleed into and overwrite the program's executable code (the code segment). Segmentation hardware would raise a fault, preventing this kind of cross-segment corruption.", narrative: "This is about organizing a program's memory like a house with different rooms for different purposes. You have a library for your books (code segment), a pantry for your food (data segment), and a workshop for projects (stack segment). Segmentation enforces rules like 'no food in the library,' preventing a mess in one room from spilling over into another.", imageUrl: "images/segmentation.png" },
            { id: 5, title: "Memory Protection Unit (MPU)", date: "~1980s", type: "hardware", what: "A hardware unit that defines a limited number of memory regions with specific access permissions, working directly with physical addresses.", how: "It checks every memory access against predefined regions. It does not perform virtual address translation like a full MMU.", protects: "A task or process corrupting the memory of another task or the kernel in real-time and embedded systems.", pioneer: "ARM Cortex-M processor family.", story: "The story is rooted in critical embedded systems. Imagine a car's infotainment system and its braking system are controlled by the same microcontroller. A bug in the music player could overwrite the memory used by the braking software, leading to catastrophic failure. An MPU creates a hardware firewall between these tasks.", narrative: "This is the lightweight version of memory protection for devices that can't afford the complexity of a full MMU, like a smart thermostat. It doesn't provide the 'private mansion' illusion of virtual memory, but it does enforce strict 'property lines' in the shared memory space, ensuring the temperature sensor code can't crash the Wi-Fi code.", imageUrl: "images/mpu.png" },
            { id: 6, title: "W^X / DEP / NX Bit", date: "~2001-2004", type: "hardware", what: "A hardware feature (No-eXecute bit or Data Execution Prevention) that marks memory pages as either writable or executable, but not both.", how: "The CPU will refuse to execute instructions from a memory page marked as 'non-executable.' This principle is known as **Write XOR Execute (W^X)**.", protects: "Code injection attacks, where an attacker writes shellcode into a buffer and then tricks the program into executing it.", pioneer: "AMD Athlon 64 processors.", story: "The quintessential story is the exploit from Aleph One's **'Smashing The Stack For Fun And Profit.'** This paper popularized injecting malicious code (shellcode) onto the stack and overwriting the return address to point to it. W^X was developed as a direct hardware countermeasure to this exact attack.", narrative: "Use the analogy of a piece of paper. You can have a piece of paper that you write on (writable memory), or a piece of paper you read instructions from (executable memory), but the CPU enforces a rule that you can't have one that's both. This stops an attacker from scribbling their own malicious instructions onto a data page and then tricking the CPU into reading it as commands.", imageUrl: "images/no-execute-bit.png" },
            { id: 7, title: "Hardware-Assisted Virtualization (HAV)", date: "~2005", type: "hardware", what: "Hardware extensions (**Intel VT-x**, **AMD-V**) that enable efficient, secure virtualization of entire operating systems.", how: "Introduces a new, more privileged CPU mode (**'Ring -1'**) for a hypervisor. The hypervisor uses hardware like **Extended Page Tables (EPT)** to create completely isolated memory spaces for each guest virtual machine.", protects: "A compromised OS in one virtual machine from accessing the memory of another VM or the host hypervisor. It is the foundation of modern cloud security.", pioneer: "Intel (VT-x) and AMD (AMD-V).", story: "The story is the birth of the modern cloud. How can Amazon or Google safely run your company's sensitive virtual machine on the same physical server as a competitor? HAV is the core technology that makes this multi-tenancy possible, providing ironclad, hardware-enforced isolation between entire operating systems.", narrative: "If an OS is a self-contained house, the hypervisor is a higher-dimensional being owning the neighborhood. The hypervisor exists in a more privileged 'Ring -1' and can build unbreakable walls between the houses. This ensures that a hostile takeover in one house can never spread to the next. VBS is a clever use of this power to protect the OS house from itself.", imageUrl: "images/hav.png" },
            { id: 8, title: "IOMMU (DMA Protection)", date: "~2005", type: "hardware", what: "An Input/Output Memory Management Unit (**Intel VT-d**, **AMD-Vi**). It is an MMU for peripheral devices.", how: "It translates device memory requests, ensuring a device can only perform **Direct Memory Access (DMA)** within its assigned memory buffers, preventing it from accessing the rest of the system's memory.", protects: "DMA attacks, where a malicious or compromised peripheral device bypasses the CPU's protections to read sensitive memory or overwrite the kernel.", pioneer: "Intel (as VT-d) and AMD (as AMD-Vi).", story: "The story is the **Thunderspy attack**. Researchers showed that by plugging a malicious device into a Thunderbolt port, they could use DMA to read the entire contents of RAM in seconds, bypassing all OS security. The IOMMU prevents this by restricting what memory a peripheral device is allowed to access.", narrative: "Frame this as building a customs checkpoint for your hardware. Just because you plug in a USB drive doesn't mean it should be allowed to wander all over your computer's memory. The IOMMU acts as a border patrol agent for every hardware device, forcing it to stay in its designated area.", imageUrl: "images/iommu.png" },
            { id: 9, title: "CHERI", date: "~2010-present", type: "hardware", what: "**Capability Hardware Enhanced RISC Instructions** is a hardware architecture that changes pointers into unforgeable 'capabilities'.", how: "A capability is a hardware token that bundles a pointer with bounds and permissions. The CPU ensures that any memory access through a capability respects its defined limits and permissions.", protects: "The root cause of most memory safety bugs, including buffer overflows and use-after-free, at a fundamental level.", pioneer: "Research project implemented in prototype hardware like the Arm Morello board.", story: "The story here is about a fundamental solution to a persistent problem. For decades, the majority of critical software vulnerabilities are memory safety bugs. CHERI's story is the attempt to re-engineer the CPU's architecture to eliminate these bug classes entirely, rather than just adding more layers of mitigation.", narrative: "Explain this as fundamentally changing the rules of the game. For 50 years, a pointer was just a number. CHERI says pointers now become 'capabilities'—like a keycard that not only opens a specific door (the address) but also knows the size of the room behind it (bounds) and what you're allowed to do inside (permissions). You can't forge it.", imageUrl: "images/cheri.png" },
            { id: 10, title: "Modern GPU Memory Protection", date: "~2010s-present", type: "hardware", what: "Modern GPUs have adopted CPU-like memory protection, centered around **Unified Virtual Memory (UVM)**, allowing the GPU and CPU to share a single virtual address space.", how: "An IOMMU is critical for enforcing memory boundaries. The OS and drivers manage page tables for the GPU, isolating processes from each other. High-end GPUs also feature TEEs for confidential computing.", protects: "A buggy shader or game crashing the system, or a malicious AI model reading data from another model running on the same GPU in the cloud.", pioneer: "NVIDIA (CUDA UVM), AMD (HSA), and modern graphics APIs.", story: "The story is about the old days where a graphics card crash would bring down the whole system. Modern GPU workloads, especially in the cloud with multiple users running AI models, demand the same level of isolation as CPUs. A bug in one user's model shouldn't let them read another user's model data.", narrative: "Frame this as the inevitable 'growing up' of the GPU. As GPUs evolved from simple graphics accelerators into powerful general-purpose computers, they had to adopt the same security and stability features that CPUs learned decades ago. The principles are the same—virtualization, isolation, privilege levels—but applied to a massively parallel architecture.", imageUrl: "images/uvm.png" },
            { id: 11, title: "SMEP / SMAP", date: "~2011", type: "hardware", what: "**Supervisor Mode Execution Prevention** and **Supervisor Mode Access Prevention** are hardware features that prevent the kernel from accessing or executing code in user-space pages.", how: "If the kernel (Ring 0) attempts to fetch instructions from or access data in a memory page marked as user-space, the CPU will raise a fault.", protects: "A class of kernel exploits where a vulnerability is used to trick the kernel into jumping to malicious code that the attacker has placed in user-space memory.", pioneer: "Intel Ivy Bridge CPUs.", story: "The story is the **'return-to-userspace'** attack. After attackers found a vulnerability in the OS kernel, they needed a way to execute their code. Instead of trying to inject new code into protected kernel memory, they would simply redirect the kernel's execution to malicious code they had already placed in their own user-mode memory. SMEP and SMAP were created to make the kernel refuse to execute code from or access data in any page marked as 'user' memory.", narrative: "Use the analogy of the king's guards. The Protection Rings stop the peasants from entering the castle. But what if a peasant tricks the king into wandering out into the peasant village to follow some bad instructions? SMEP/SMAP are the king's personal bodyguards who stop him at the castle gate, saying, 'My lord, you should never be taking orders from out there.'", imageUrl: "images/smep-smap.png" },
            { id: 12, title: "Intel MPX", date: "~2013-2019", type: "hardware", what: "**Memory Protection Extensions** were a set of CPU instructions designed to bring hardware-accelerated bounds checking to legacy C/C++ code.", how: "Compilers could add MPX instructions to store the bounds of an allocation in special registers. The CPU hardware would then check every memory access against these bounds.", protects: "Buffer overflows, by catching them at the hardware level.", pioneer: "Intel Skylake CPUs.", story: "The story of MPX is a cautionary tale about a well-intentioned feature that failed. Intel wanted to solve buffer overflows at the hardware level, but the implementation crippled application performance (30-200%+ slowdown). Developers chose performance over security, so the feature was never used and eventually abandoned.", narrative: "This slide is the story of a 'noble failure.' It's a fantastic idea—let's use hardware to fix C++'s biggest problem! But it teaches a critical lesson: a security feature that is too slow is a useless feature. Its failure highlighted the challenge of retrofitting security and paved the way for more efficient designs like MTE and PAC.", imageUrl: "images/mpx.png" },
            { id: 13, title: "Memory Encryption", date: "~2015", type: "hardware", what: "A hardware feature that provides transparent, high-performance encryption of the main memory (RAM).", how: "A dedicated engine on the CPU automatically encrypts data as it's written to RAM and decrypts it when read back. The encryption keys are managed by the CPU and are not accessible to software.", protects: "Physical attacks where an adversary has access to the hardware, such as **'cold boot' attacks** where RAM modules are frozen and read.", pioneer: "Intel TME and AMD SME/SEV.", story: "The classic story is the **Cold Boot Attack**. In 2008, researchers demonstrated that by freezing RAM chips with compressed air, the data would persist for several minutes after power-off. They could then reboot and dump the RAM's contents to extract sensitive data like disk encryption keys. Total Memory Encryption directly defeats this.", narrative: "Describe this as writing everything down in a secret code. This is about what happens if a thief physically steals your computer. Even if they take out the RAM sticks, they can't read them because it's all encrypted. Only the CPU that wrote the data holds the secret key to decipher it.", imageUrl: "images/memory-encryption.png" },
            { id: 14, title: "TEE / Intel SGX", date: "~2015", type: "hardware", what: "A **Trusted Execution Environment** is a hardware feature that creates a secure area inside the CPU called an 'enclave,' isolated from the host OS.", how: "Memory pages belonging to the enclave are encrypted. Code and data are only decrypted inside the CPU itself and are inaccessible even to Ring 0.", protects: "A compromised or malicious OS or hypervisor from reading or tampering with an application's sensitive data.", pioneer: "Intel SGX (Software Guard Extensions).", story: "The story is about **cloud security**. A company wants to process sensitive client data in the cloud but doesn't fully trust the cloud provider's administrators. SGX allows them to run their application in a secure 'enclave.' The data is encrypted, and not even the cloud provider's OS or hypervisor can access the code or data inside.", narrative: "This is like a secure vault *inside* the CPU. We've protected apps from each other, and the OS from apps. But what if the OS itself is the bad guy? A TEE is a black box where an application can run its most sensitive operations. Even if the bank manager (the OS) has keys to the building, they cannot see what's inside this specific, hardware-protected vault.", imageUrl: "images/sgx.png" },
            { id: 15, title: "Virtualization-Based Security (VBS)", date: "~2015", type: "hardware", what: "A hardware-assisted feature that uses virtualization extensions to create isolated regions of memory to host critical security processes.", how: "VBS creates a 'Secure Kernel' running under a hypervisor. This Secure Kernel enforces security policies (like code integrity) on the main OS. The CPU's hardware enforces this isolation.", protects: "Attacks from a compromised kernel (Ring 0), such as injecting malicious drivers or malware that tries to patch the kernel.", pioneer: "Microsoft Windows 10.", story: "The story is about defeating advanced **kernel-mode rootkits**. A sophisticated rootkit like TDL-4 could patch the running OS kernel in memory to hide files and its own processes. VBS uses the hypervisor to protect the Windows kernel, making this kind of in-memory patching impossible because the integrity-checking code runs from a more privileged, hardware-isolated environment.", narrative: "Explain this as having a security guard (the hypervisor) who watches the bank manager (the OS). We use the hardware designed to run multiple operating systems, but instead put the OS in one VM and the critical security functions in another, more privileged, VM. The hardware acts as the wall between them, so the guard can watch the manager, but the manager can't touch the guard.", imageUrl: "images/vbs.png" },
            { id: 16, title: "Control-Flow Enforcement Technology (CET)", date: "~2016", type: "hardware", what: "A hardware feature that provides stronger protection against control-flow hijacking attacks. It includes a **Shadow Stack** for return addresses and **Indirect Branch Tracking** for jumps.", how: "The Shadow Stack is a hardware-protected copy of return addresses, checked on function return. Indirect Branch Tracking ensures jumps and calls land only on special `ENDBRANCH` instructions.", protects: "**Return-Oriented Programming (ROP)** and **Jump-Oriented Programming (JOP)** attacks at the hardware level.", pioneer: "Intel 'Tiger Lake' (11th Gen Core) CPUs.", story: "The story is **Return-Oriented Programming (ROP)**. After W^X stopped code injection, attackers realized they could chain small, existing code snippets ('gadgets') together. By carefully crafting the stack, they could make the program execute complex operations. CET's Shadow Stack is a direct defense, as it detects that the function returns are not going back to their original call sites.", narrative: "This is about enforcing the program's intended travel plan. The Shadow Stack acts like a GPS log for function calls, ensuring that when you return from a trip, you come back to exactly where you started. Indirect Branch Tracking is like ensuring you only get off a train at official, marked stations, not in a dark field where an attacker is waiting.", imageUrl: "images/cet.png" },
            { id: 17, title: "Speculative Execution Attacks", date: "~2018", type: "hardware", what: "A class of hardware vulnerabilities (e.g., **Spectre & Meltdown**) that exploit speculative execution to leak secret data via side channels.", how: "An attacker tricks the CPU into speculatively accessing secret data it shouldn't be able to. The access leaves traces in the CPU's caches, which can be measured to infer the secret data.", protects: "These attacks broke fundamental isolation boundaries, allowing user-space to read kernel memory. Mitigations are complex software and hardware changes.", pioneer: "Discovered by independent research teams, including Google's Project Zero.", story: "The story that shocked the industry. A proof-of-concept showed that malicious JavaScript in one browser tab could exploit these vulnerabilities to **read memory from other tabs**, stealing passwords or session cookies. It broke the most fundamental security boundary in modern computing—the isolation between processes.", narrative: "Use the analogy of a ghost. You can't see the ghost directly, but you can see the footprints it leaves behind in the dust. The CPU, in its quest for performance, 'ghosts' an action by speculatively accessing secret data. Even though the data is thrown away, the 'footprints' it leaves in the CPU cache can be seen by an attacker, revealing the secret. This isn't about corrupting memory; it's about leaking it.", imageUrl: "images/spectre.png" },
            { id: 18, title: "Pointer Authentication Codes (PAC)", date: "~2018", type: "hardware", what: "An ARM hardware feature that provides cryptographic protection for pointers.", how: "A cryptographic signature ('PAC') is calculated for a pointer using its value, context, and a secret key, and stored in its unused bits. Before the pointer is used, the hardware re-calculates and verifies the signature.", protects: "A wide range of attacks that rely on modifying pointers, including return addresses and function pointers.", pioneer: "Apple A12 Bionic SoC (implementing ARMv8.3-A).", story: "The story is about making **iOS exploits** incredibly difficult. Before PAC, many jailbreaks and remote exploits for iPhones worked by finding a memory corruption bug and using it to modify a critical pointer to gain control. By cryptographically signing these pointers, PAC ensures that any such modification is detected, crashing the app instead of allowing the exploit to succeed.", narrative: "This is like putting a unique, tamper-proof wax seal on every address before you store it. The seal is created using a secret key only the CPU knows. Before you use the address, the CPU checks if the seal is unbroken. If an attacker messes with the address, the seal breaks, and the CPU raises an alarm.", imageUrl: "images/pac.png" },
            { id: 19, title: "Memory Tagging Extension (MTE)", date: "~2019", type: "hardware", what: "An ARM hardware feature that helps detect memory safety violations, both spatial (out-of-bounds) and temporal (use-after-free).", how: "Memory is divided into small chunks, and each chunk gets a 4-bit 'tag' (the lock). When a pointer to that memory is created, it gets the same 4-bit tag (the key). On every access, the hardware checks that the key in the pointer matches the lock on the memory.", protects: "Buffer overflows and use-after-free bugs with high performance, making runtime detection practical for production devices.", pioneer: "Google Tensor G3 SoC (implementing ARMv8.5-A).", story: "The story is about making memory bug detection efficient enough for everyone. Tools like ASan are great for developers but are too slow to ship to customers. MTE is designed to be the hardware version of ASan, making it fast enough to be enabled on billions of consumer Android devices to detect and report memory bugs that happen 'in the wild.'", narrative: "Use a lock-and-key analogy. When you allocate memory, the hardware puts a colored lock on it (e.g., a 'red' tag). The pointer you get is a 'red' key. If a buffer overflow makes your pointer go into a neighboring 'blue' memory region, the hardware will see you trying to use a red key on a blue lock, and the alarm will go off.", imageUrl: "images/mte.png" },
            { id: 20, title: "Stack Canaries / StackGuard", date: "~1998", type: "software", what: "A compiler-based security feature to detect stack buffer overflows.", how: "A small, random integer (the 'canary') is placed on the stack before the function's return address. Before the function returns, the canary's value is checked. If it was overwritten, the program terminates.", protects: "Classic stack smashing attacks that overwrite the return address to hijack program execution.", pioneer: "StackGuard research paper, later integrated into GCC.", story: "This is the original software defense against **'Smashing The Stack.'** Before W^X was common, StackGuard introduced the idea of placing a random value on the stack. Any linear buffer overflow would have to overwrite the canary to reach the return address, thus tripping the alarm.", narrative: "The analogy is literal: it's a canary in a coal mine. You place a secret value on the stack between your local variables and the critical return address. If a buffer overflows, it must 'kill' the canary. Before returning, the code checks if the canary is still alive. If not, it halts the program instead of making a compromised jump.", imageUrl: "https://placehold.co/400x300/EFE8D9/4A4A4A?text=Stack+Canary" },
            { id: 21, title: "Heap Protections", date: "~2000s", type: "software", what: "A suite of security features built into modern heap memory allocators to mitigate heap-based memory corruption.", how: "Includes techniques like metadata integrity checks, **safe unlinking** to prevent pointer corruption during `free()`, and randomization of heap chunk locations.", protects: "Heap overflows, use-after-free, double-free, and other attacks that corrupt the heap's internal data structures.", pioneer: "Ongoing development in `ptmalloc` for Linux and the Windows Heap Manager.", story: "The classic story is the **'unlink' exploit**. By overflowing a buffer in one heap chunk, an attacker could corrupt the metadata of a neighboring free chunk. When `free()` was called, the allocator's 'unlink' macro would be tricked into writing an arbitrary value to an arbitrary memory location, leading to a full system compromise. 'Safe Unlinking' was a specific check added to prevent this.", narrative: "If the stack is a neat pile of plates, the heap is a chaotic warehouse of boxes. These protections are like adding inventory control: checking labels on boxes before moving them (metadata integrity), ensuring that removing a box doesn't cause the shelf to collapse (safe unlinking), and shuffling the layout every day (randomization).", imageUrl: "https://placehold.co/400x300/EFE8D9/4A4A4A?text=Heap+Guards" },
            { id: 22, title: "ASLR", date: "~2001", type: "software", what: "**Address Space Layout Randomization** is an OS-level defense that randomizes the memory locations of key process areas.", how: "Each time a program is run, the OS places the stack, heap, and libraries at different, unpredictable memory addresses.", protects: "Makes it much harder for an attacker to use exploits that rely on knowing the address of specific code, such as **Return-to-libc attacks** or ROP.", pioneer: "The PaX project for the Linux kernel.", story: "The story is the **Return-to-libc attack**. An exploit would overwrite a return address to point to a function like `system()` inside `libc`. This worked because `libc` was always loaded at a predictable address. ASLR defeats this by loading `libc` at a different, random address every time.", narrative: "This is like shuffling the layout of a city every morning. An attacker might have a map to the bank, but today the bank is where the post office was yesterday. It makes finding specific targets based on a static, known address nearly impossible, forcing the attacker to guess.", imageUrl: "https://placehold.co/400x300/EFE8D9/4A4A4A?text=ASLR" },
            { id: 23, title: "Position-Independent Executables (PIE)", date: "~2003", type: "software", what: "A compiler/linker feature that generates an application binary that can be loaded and run from any memory address.", how: "The code doesn't use absolute addresses; it uses relative addresses to access its data and functions.", protects: "Completes ASLR protection by allowing the main application executable itself to be randomized, not just libraries.", pioneer: "The PaX project for the Linux kernel.", story: "This closes a major loophole in ASLR. While ASLR randomized libraries, the main application executable was often still loaded at a fixed address. Attackers simply adapted their ROP exploits to use gadgets from the main executable's code. PIE allows the application executable itself to be randomized.", narrative: "This completes the city-shuffling analogy. Standard ASLR shuffles the surrounding districts, but without PIE, the main town hall (the application) is stuck in the same place. PIE allows the OS to pick up the town hall and move it to a random location as well, so the *entire* city layout is unpredictable.", imageUrl: "https://placehold.co/400x300/EFE8D9/4A4A4A?text=PIE" },
            { id: 24, title: "Kernel Patch Protection / PatchGuard", date: "~2005", type: "software", what: "A security feature in 64-bit Windows that periodically checks for unauthorized modifications to the kernel.", how: "At random intervals, it verifies the integrity of critical kernel code and data structures. If any modification is detected, it deliberately crashes the system.", protects: "Rootkits and other malware that modify the core OS in memory to hide their presence or hijack system functions.", pioneer: "Microsoft Windows XP Professional x64 Edition.", story: "The story is the arms race between **rootkits and antivirus software**. Many early rootkits would modify the Windows kernel in memory (e.g., patching the System Service Dispatch Table). PatchGuard was Microsoft's solution to end this, declaring that *any* modification to the core kernel was illicit, and it would crash the system to prevent it.", narrative: "Imagine the OS kernel is the constitution of a country. PatchGuard is like a group of guardians who periodically read the constitution to make sure no one has scribbled in the margins. If they find any unauthorized changes, they shut down the country (crash the system) to prevent a tyranny from taking hold.", imageUrl: "https://placehold.co/400x300/EFE8D9/4A4A4A?text=PatchGuard" },
            { id: 25, title: "Kernel ASLR (KASLR)", date: "~2005", type: "software", what: "**Kernel Address Space Layout Randomization** is an OS-level defense that randomizes the memory location where the kernel itself is loaded on each boot.", how: "It extends the principle of ASLR to the most privileged component of the OS, making the location of kernel code and data unpredictable.", protects: "Kernel-level exploits that rely on knowing the static addresses of kernel functions or data structures.", pioneer: "The PaX project, later adopted by all major operating systems.", story: "The story is about making **kernel exploits unreliable**. An attacker might find a vulnerability in a driver, but to use it, their exploit needs to know the addresses of key kernel functions. KASLR forces an attacker to first find a separate information leak vulnerability just to figure out where to jump, dramatically increasing exploit complexity.", narrative: "This is applying our city-shuffling analogy to the most important building: the government headquarters (the kernel). By moving the kernel to a random address in memory on every boot, it's much harder for attackers who've broken into the city to find and attack the seat of power.", imageUrl: "https://placehold.co/400x300/EFE8D9/4A4A4A?text=KASLR" },
            { id: 26, title: "SEHOP", date: "~2007", type: "software", what: "**Structured Exception Handler Overwrite Protection** is a Windows-specific mitigation that protects the exception handling chain stored on the stack.", how: "Before allowing an exception handler to run, the OS walks the list of handlers to ensure it is valid and has not been corrupted, checking that the chain correctly ends at a default OS handler.", protects: "Attacks that overwrite an exception handler record on the stack to gain control of execution flow when an error occurs.", pioneer: "Microsoft Windows Vista Service Pack 1.", story: "The story is about an alternative to stack smashing on Windows. Instead of overwriting a return address, an attacker could overwrite a pointer in the **Structured Exception Handler (SEH)** chain on the stack. They could then trigger a simple error (like a divide-by-zero), causing the OS to walk the corrupted chain and execute their code. SEHOP validates this chain before using it.", narrative: "Think of the exception handler chain as the list of emergency contacts on your phone. An attacker could scratch out your doctor's number and write in their own. When you have an emergency, you end up calling the attacker. SEHOP is like your phone first checking that the list of contacts is valid and ends with 911 before making the call.", imageUrl: "https://placehold.co/400x300/EFE8D9/4A4A4A?text=SEHOP" },
            { id: 27, title: "Application Sandboxing", date: "~2008", type: "software", what: "A software security mechanism that enforces the **'Principle of Least Privilege'** by confining a process to a very limited set of system resources.", how: "An outer process sets up strict rules using kernel features (like `seccomp-bpf` on Linux) that govern what a sandboxed child process is allowed to do (e.g., no file or network access).", protects: "A vulnerability in one application from being used to compromise the entire system. It contains the damage of a successful exploit.", pioneer: "Widely popularized by Google Chrome.", story: "The story is the **architecture of Google Chrome**. Previous browsers ran as a single process; a bug in the code that renders a malicious webpage could take over the user's entire computer. Chrome pioneered a model where the page renderer runs in a separate, heavily restricted 'sandbox' process. Even if an attacker finds an exploit, the sandbox prevents them from reading files or accessing other system resources.", narrative: "This is like hiring a plumber but only letting them into the bathroom. They can do their job, but they are physically prevented from wandering around your house. Even if the plumber is secretly a spy, the damage they can do is contained to that one room. Sandboxing applies this principle to software, containing the blast radius of any exploit.", imageUrl: "https://placehold.co/400x300/EFE8D9/4A4A4A?text=Sandboxing" },
            { id: 28, title: "AddressSanitizer (ASan)", date: "~2011", type: "software", what: "A powerful compiler-based instrumentation tool for detecting memory safety errors.", how: "The compiler adds checks around every memory access. It uses 'shadow memory' to keep track of which bytes are safe to access. If an invalid access occurs (e.g., out-of-bounds, use-after-free), the program crashes immediately with a detailed report.", protects: "A wide range of memory corruption bugs during development and testing. It revolutionized practical bug finding.", pioneer: "Google, integrated into LLVM/Clang and GCC compilers.", story: "The story is about making bug detection practical at scale. Before ASan, tools like Valgrind could find memory bugs but were often 20x slower, making them unusable for large projects. ASan, with only a ~2x slowdown, was a revolution. It allowed companies like Google to enable memory-error checking during their entire automated testing process, finding thousands of bugs automatically.", narrative: "This is like having a meticulous inspector watch your every move while you build something. The instant you try to use a screw that's too short (an invalid memory access), the inspector stops the project and gives you a detailed report on what you did wrong. It's amazing for quality control but too slow to ship in the final product.", imageUrl: "https://placehold.co/400x300/EFE8D9/4A4A4A?text=ASan" },
            { id: 29, title: "Control Flow Guard (CFG)", date: "~2014", type: "software", what: "A compiler and OS mitigation that restricts where indirect calls (like virtual function calls or calls through function pointers) can go.", how: "The compiler identifies all valid targets for indirect calls and builds a bitmap of these 'safe' locations. The OS checks the target address against the bitmap before executing the call.", protects: "Exploits that corrupt function pointers or vtable pointers to redirect execution to malicious code.", pioneer: "Microsoft Windows 8.1 Update 3.", story: "The story is the bypass of W^X and ASLR. Attackers would find a memory corruption bug and use it to overwrite a **C++ virtual function pointer**. When the program later made a virtual call, it would be redirected to the attacker's ROP chain. CFG ensures that such an indirect call can only land on a location that the compiler has previously marked as a valid function start.", narrative: "Think of a program's execution as a train on a railway. Indirect calls are like junctions. CFG is a signaling system that ensures the train can only switch to tracks that lead to an officially designated station, not a dead end or a malicious sidetrack built by an attacker. This is a 'coarse-grained' check.", imageUrl: "https://placehold.co/400x300/EFE8D9/4A4A4A?text=CFG" },
            { id: 30, "title": "JIT Hardening", "date": "~2010s-present", "type": "software", "what": "A collection of security techniques used to protect code generated by **Just-In-Time (JIT)** compilers.", "how": "Defenses include **JIT-specific ASLR** (constantly re-randomizing the location of newly generated code) and **Constant Blinding** (encrypting or hiding constants within the JIT code).", "protects": "Exploits targeting the JIT compilation process itself, a major attack surface in modern web browsers and language runtimes.", "pioneer": "Modern browser engines like V8 (Chrome) and SpiderMonkey (Firefox).", "story": "The story is the **Pwn2Own hacking competition**, where for many years, the primary way to win was to find a bug in the JIT compiler of a web browser. In response, browser vendors have poured immense effort into hardening their JIT engines, making browser exploitation far more difficult.", "narrative": "A JIT compiler is like a magical machine that writes new pages for a book while you're reading it. This is inherently dangerous. JIT hardening is like making the machine write on special, randomized paper and using invisible ink for secret constants, making it much harder for an attacker to abuse the process.", "imageUrl": "https://placehold.co/400x300/EFE8D9/4A4A4A?text=JIT+Hardening" },
            { id: 31, "title": "Fine-Grained CFI", "date": "~2010s-present", "type": "software", "what": "A more precise, often compiler-based, implementation of **Control-Flow Integrity (CFI)**.", "how": "It goes beyond coarse-grained CFI (which checks if a call target is a valid function start) by also checking if the function being called has the **correct type signature**.", "protects": "More advanced control-flow hijacking attacks that bypass coarse-grained checks by redirecting execution to a valid but incorrect function.", "pioneer": "Research projects and advanced implementations in compilers like Clang's CFI.", "story": "This story is about the bypass of coarse-grained CFI. Attackers realized that while CFG prevents them from calling just anywhere, it doesn't stop them from calling a *valid but incorrect* function. An exploit could replace a call to a function that takes three arguments with a call to a different, valid function that takes zero arguments, leading to stack corruption. Fine-grained CFI checks the function's type signature, defeating this subtle attack.", "narrative": "This takes the train analogy further. Coarse-grained CFG ensures the train arrives at *a* station. Fine-grained CFI ensures it arrives at the *correct* station. If the ticket says 'Express to Paris' (function signature A), it won't let the train switch to a track going to 'Local to Berlin' (function signature B), even if Berlin is a valid station.", "imageUrl": "https://placehold.co/400x300/EFE8D9/4A4A4A?text=Fine-Grained+CFI" },
            { id: 32, "title": "Data-Flow Integrity (DFI)", "date": "~2010s-Research", "type": "software", "what": "A strong security policy that complements CFI by preventing attacks on a program's data, even if the control flow is valid.", "how": "A pre-computed 'data-flow graph' defines all legitimate sources and destinations for critical data. Runtime instrumentation then enforces this graph.", "protects": "Data-only attacks (like **Data-Oriented Programming - DOP**) that corrupt critical variables (e.g., an `isAdmin` flag) without hijacking program execution.", "pioneer": "An active area of academic research.", "story": "The story is **Data-Oriented Programming (DOP)**. Researchers showed that even with perfect control-flow integrity, an attacker doesn't need to change *where* the program executes. Instead, they can corrupt critical data (e.g., changing a user's permissions from `is_admin = false` to `true`) using the program's existing, valid code. DFI is the conceptual defense against this.", "narrative": "Imagine you have perfect security guards (CFI) who ensure no one enters an unauthorized room. But what if a legitimate person (valid control flow) is hypnotized into swapping the labels on the 'salt' and 'sugar' jars? DFI is like having a rulebook that says only the chef is allowed to touch the sugar jar. It controls not just *where* you can go, but *what data* you can touch.", "imageUrl": "https://placehold.co/400x300/EFE8D9/4A4A4A?text=DFI" },
            { id: 33, "title": "Memory-Safe Languages", "date": "~2010s", "type": "software", "what": "A programming language design philosophy that eliminates entire classes of memory safety bugs at compile time.", "how": "The language's type system and compiler enforce strict rules about memory ownership, lifetimes, and borrowing. The compiler will refuse to build code that could lead to a dangling pointer or buffer overflow.", "protects": "The root cause of many memory vulnerabilities by making them impossible (or very difficult) to write in the first place.", "pioneer": "Rust, with influences from earlier academic languages like Cyclone.", "story": "The story is the industry's acknowledgement of failure. After 20+ years of adding mitigations to C/C++ code, developers were still writing the same bugs. The story of Rust is one of *prevention*, aiming to create a system where these bug classes are caught by the compiler and are impossible to ship, rather than relying on an ever-growing list of runtime mitigations.", "narrative": "This is like inventing a new kind of LEGO brick that physically cannot be connected in a way that would make the structure unstable. For decades, we gave programmers regular bricks (C/C++) and a long list of instructions on how to build safely. This approach shifts the burden to the tools. The building blocks themselves enforce safety.", "imageUrl": "https://placehold.co/400x300/EFE8D9/4A4A4A?text=Rust+Language" },
            { id: 34, title: "Conclusion & Questions", date: "Present Day", type: "none", what: "An ongoing arms race between attackers and defenders continues to drive innovation in computer security.", how: "The most secure systems use a combination of both hardware and software mitigations, a strategy known as **Defense in Depth**. The industry is also 'shifting left,' focusing on preventing bugs at the source with memory-safe languages.", protects: "This slide summarizes the key takeaways and opens the floor for discussion.", pioneer: "Thank you!", story: "The key takeaway is that no single protection is a silver bullet. Security is built in layers, with hardware providing the foundation and software adding crucial flexibility. The future is a combination of stronger hardware guarantees and wider adoption of memory-safe programming languages to prevent vulnerabilities before they are even created.", narrative: "And that brings us to today. As we've seen, the history of memory protection is a fascinating story of action and reaction. For every new defense, a new attack is developed, and for every new attack, a new defense is engineered. It's an arms race that has made our systems orders of magnitude more resilient than they were decades ago. The most important lesson is that security isn't just one thing; it's a deep, layered strategy, and increasingly, it's about building safety in from the very start. Thank you for your time. I'd now be happy to answer any questions you may have.", imageUrl: "https://placehold.co/400x300/EFE8D9/4A4A4A?text=Questions?" }
        ];

        document.addEventListener('DOMContentLoaded', () => {
            const timeline = document.getElementById('timeline');
            const detailsPanel = document.getElementById('details-panel');
            const filterAll = document.getElementById('filter-all');
            const filterHardware = document.getElementById('filter-hardware');
            const filterSoftware = document.getElementById('filter-software');
            
            let currentActiveId = null;
            let notesWindow = null;

            function markdownToHtml(text) {
                if (!text) return '';
                return text
                    .replace(/`([^`]+)`/g, '<code class="bg-gray-100 text-indigo-700 py-0.5 px-1.5 rounded-md font-mono text-sm">\$1</code>')
                    .replace(/\*\*([^\*]+)\*\*/g, '<strong class="font-semibold text-gray-900">\$1</strong>');
            }

            function renderTimeline(filter = 'all') {
                timeline.innerHTML = '';
                const filteredData = protectionData.filter(item => {
                    if (filter === 'all') return true;
                    if (filter === 'hardware') return item.type === 'hardware' || item.type === 'intro' || item.type === 'none';
                    if (filter === 'software') return item.type === 'software' || item.type === 'intro' || item.type === 'none';
                });

                filteredData.forEach((item) => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'timeline-item';
                    itemDiv.dataset.id = item.id;
                    itemDiv.dataset.type = item.type;
                    itemDiv.innerHTML = `
                        <div class="timeline-dot"></div>
                        <div class="timeline-content">
                            <p class="text-sm font-semibold">${item.title}</p>
                            <p class="text-xs text-gray-500">${item.date}</p>
                        </div>
                    `;
                    timeline.appendChild(itemDiv);
                });
                
                timeline.querySelectorAll('.timeline-item').forEach(item => {
                    item.addEventListener('click', () => {
                        updateDetails(item.dataset.id);
                    });
                });
            }

            function updateDetails(id) {
                if(currentActiveId == id) return;
                
                const data = protectionData.find(d => d.id == id);
                if (!data) return;

                currentActiveId = id;

                timeline.querySelectorAll('.timeline-item').forEach(item => {
                    item.classList.toggle('active', item.dataset.id == id);
                });

                if (data.type === 'intro') {
                    detailsPanel.innerHTML = `
                        <div class="card p-6 md:p-8 h-full flex items-center justify-center">
                            <div class="flex flex-col sm:flex-row items-center gap-6 text-center sm:text-left">
                                <img src="${data.photoUrl}" alt="Speaker photo" class="w-32 h-32 rounded-full object-cover border-4 border-white shadow-lg">
                                <div>
                                    <h2 class="text-3xl md:text-4xl font-bold text-gray-800">${data.title}</h2>
                                    <p class="text-lg text-gray-600 mt-4">${markdownToHtml(data.bio)}</p>
                                </div>
                            </div>
                        </div>`;
                } else {
                    const typeColorClass = data.type === 'hardware' ? 'blue' : (data.type === 'software' ? 'emerald' : 'gray');
                    let contentHtml = '';
                    if (data.id === 34) { // Conclusion slide
                         contentHtml = `
                            <div class="h-full flex flex-col justify-center items-center text-center">
                                <h3 class="text-2xl font-semibold mb-4 text-gray-700">Key Takeaways</h3>
                                <ul class="text-lg space-y-3 mb-8 text-left">
                                    <li>${markdownToHtml('🛡️ Security is built in layers (**Defense in Depth**).')}</li>
                                    <li>${markdownToHtml('⚙️ Hardware provides the foundation, software provides flexibility.')}</li>
                                    <li>${markdownToHtml('🔥 The attacker-defender dynamic is a constant arms race.')}</li>
                                    <li>${markdownToHtml('⬅️ The industry is "shifting left" to prevent bugs with **Memory-Safe Languages**.')}</li>
                                </ul>
                                <h2 class="text-5xl font-bold text-gray-800">Questions?</h2>
                            </div>
                         `;
                    } else {
                        contentHtml = `
                            <div class="flex-shrink-0 flex flex-col md:flex-row justify-between md:items-center mb-6">
                               <h2 class="text-2xl md:text-3xl font-bold text-gray-800">${data.title}</h2>
                               <span class="text-sm font-semibold text-white bg-${typeColorClass}-500 px-3 py-1 rounded-full mt-2 md:mt-0 capitalize">${data.type !== 'none' ? data.type : 'Historical Context'}</span>
                            </div>
                            
                            <div class="flex-grow grid grid-cols-1 lg:grid-cols-3 gap-8">
                                <div class="lg:col-span-2 overflow-y-auto">
                                    <h3 class="text-xl font-semibold border-b-2 border-gray-200 pb-2 mb-4 text-gray-700">Technical Overview</h3>
                                    <dl class="space-y-6 text-lg">
                                        <div><dt class="font-semibold text-gray-600">What it is:</dt><dd class="text-gray-800">${markdownToHtml(data.what)}</dd></div>
                                        <div><dt class="font-semibold text-gray-600">How it works:</dt><dd class="text-gray-800">${markdownToHtml(data.how)}</dd></div>
                                        <div><dt class="font-semibold text-gray-600">Protects against:</dt><dd class="text-gray-800">${markdownToHtml(data.protects)}</dd></div>
                                        <div><dt class="font-semibold text-gray-600">Pioneered by:</dt><dd class="text-gray-800">${markdownToHtml(data.pioneer)}</dd></div>
                                    </dl>
                                </div>
                                <div class="lg:col-span-1 flex items-center justify-center">
                                    <div class="card w-full max-w-xs overflow-hidden">
                                        <img src="${data.imageUrl}" alt="Illustration for ${data.title}" class="w-full h-full object-contain" onerror="this.onerror=null;this.src='https://placehold.co/400x300/EFE8D9/4A4A4A?text=Image';">
                                    </div>
                                </div>
                            </div>
                        `;
                    }

                    detailsPanel.innerHTML = `<div class="card p-6 md:p-8 h-full flex flex-col">${contentHtml}</div>`;
                }

                detailsPanel.classList.remove('fade-in');
                void detailsPanel.offsetWidth;
                detailsPanel.classList.add('fade-in');
                updateNotesWindowContent();
            }
            
            function setActiveFilterButton(activeBtn) {
                 [filterAll, filterHardware, filterSoftware].forEach(btn => {
                    btn.classList.remove('active');
                });
                activeBtn.classList.add('active');
            }

            function handleFilterClick(filter) {
                renderTimeline(filter);
                setActiveFilterButton(document.getElementById(`filter-${filter}`));
                const firstItem = timeline.querySelector('.timeline-item');
                if(firstItem){
                    updateDetails(firstItem.dataset.id);
                } else {
                    detailsPanel.innerHTML = '';
                    currentActiveId = null;
                }
            }

            filterAll.addEventListener('click', () => handleFilterClick('all'));
            filterHardware.addEventListener('click', () => handleFilterClick('hardware'));
            filterSoftware.addEventListener('click', () => handleFilterClick('software'));

            // Initial Load
            handleFilterClick('all');

            function updateNotesWindowContent() {
                if (!notesWindow || notesWindow.closed) {
                    notesWindow = null;
                    return;
                }
                
                if (currentActiveId === null) return;
                const data = protectionData.find(d => d.id == currentActiveId);
                if (!data || !data.story) {
                    notesWindow.document.body.innerHTML = `<div class="p-8 text-gray-500">No speaker notes for this item.</div>`;
                    return;
                }

                const notesHtml = `
                    <div class="p-6 md:p-8">
                        <h2 class="text-2xl md:text-3xl font-bold text-gray-800 mb-6">${data.title} - Speaker Notes</h2>
                        <div class="space-y-6 text-gray-700">
                            <div>
                                <h3 class="text-lg font-semibold border-b border-gray-200 pb-2 mb-3 text-gray-600">Key Exploit Story</h3>
                                <p class="text-sm leading-relaxed">${markdownToHtml(data.story)}</p>
                            </div>
                            <div>
                                <h3 class="text-lg font-semibold border-b border-gray-200 pb-2 mb-3 text-gray-600">Narrative</h3>
                                <p class="text-sm leading-relaxed">${markdownToHtml(data.narrative)}</p>
                            </div>
                        </div>
                    </div>
                `;
                notesWindow.document.body.innerHTML = notesHtml;
            }

            function showNotesWindow() {
                if (notesWindow && !notesWindow.closed) {
                    notesWindow.focus();
                    return;
                }

                notesWindow = window.open("", "SpeakerNotes", "width=800,height=600,scrollbars=yes,resizable=yes");
                
                if (notesWindow) {
                    notesWindow.document.head.innerHTML = `
                        <meta charset="UTF-8">
                        <title>Speaker Notes</title>
                        <script src="https://cdn.tailwindcss.com"><\/script>
                        <link rel="preconnect" href="https://fonts.googleapis.com">
                        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
                        <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
                        <style>
                            body { font-family: 'Inter', sans-serif; background-color: #FDFBF8; color: #4A4A4A; }
                            code { background-color: #F3F4F6; color: #4338CA; padding: 2px 6px; border-radius: 4px; font-family: monospace; }
                            strong { font-weight: 700; color: #1F2937; }
                        </style>
                    `;
                    notesWindow.document.body.className = "antialiased";
                    
                    setTimeout(updateNotesWindowContent, 100); 
                }
            }

            function navigateTimeline(direction) {
                const currentActiveItem = timeline.querySelector('.timeline-item.active');
                if (!currentActiveItem) return;

                let nextItem;
                if (direction === 'next') {
                    nextItem = currentActiveItem.nextElementSibling;
                } else { 
                    nextItem = currentActiveItem.previousElementSibling;
                }

                if (nextItem) {
                    const nextId = nextItem.dataset.id;
                    updateDetails(nextId);
                    nextItem.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
                }
            }

            document.addEventListener('keydown', (event) => {
                if (event.key === 'ArrowRight' || event.key === 'PageDown') {
                    navigateTimeline('next');
                } else if (event.key === 'ArrowLeft' || event.key === 'PageUp') {
                    navigateTimeline('prev');
                } else if (event.key.toLowerCase() === 's') {
                    event.preventDefault();
                    showNotesWindow();
                } else if (event.key === 'Escape') {
                    if (notesWindow && !notesWindow.closed) {
                        notesWindow.close();
                    }
                }
            });
        });
    </script>
</body>
</html>

